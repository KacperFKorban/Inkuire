package org.virtuslab.inkuire.plugin.translators

import org.jetbrains.dokka.DokkaConfiguration
import org.jetbrains.dokka.analysis.DescriptorDocumentableSource
import org.jetbrains.dokka.analysis.PsiDocumentableSource
import org.jetbrains.dokka.model.*
import org.jetbrains.dokka.pages.*
import org.jetbrains.kotlin.descriptors.CallableMemberDescriptor
import org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind.FAKE_OVERRIDE
import org.virtuslab.inkuire.kotlin.model.AncestryGraph
import org.virtuslab.inkuire.kotlin.model.SDFunction
import org.virtuslab.inkuire.kotlin.model.STypeConstructor
import org.virtuslab.inkuire.kotlin.model.util.CustomGson
import org.virtuslab.inkuire.plugin.content.InkuireContentPage
import org.virtuslab.inkuire.plugin.transformers.DefaultDokkaToSerializableModelTransformer.toSerializable
import org.virtuslab.inkuire.plugin.transformers.anyAndNothingAppender
import org.virtuslab.inkuire.plugin.transformers.functionalTypesNormalizerTransformer
import org.virtuslab.inkuire.plugin.transformers.javaPrimitivesMapper

abstract class InkuireDocumentableToPageTranslator {

    abstract fun renderingStrategy(callback: (LocationResolver?, DokkaConfiguration.DokkaSourceSet) -> String, sourceSet: DokkaConfiguration.DokkaSourceSet): RenderingStrategy

    fun invoke(module: DModule): List<PageNode> = module.packages.let { packages ->
        packages.flatMap {
            it.functions +
                it.properties.mapNotNull { it.getter } +
                it.classlikes.flatMap { classlike -> classlike.getFunctions() }
        }.javaPrimitivesMapper().functionalTypesNormalizerTransformer()
    }.let { functions ->
        module.sourceSets.flatMap { sourceSet ->
            val callback: (LocationResolver?, DokkaConfiguration.DokkaSourceSet) -> String = { locationResolver, sourceSet ->
                functions.filter {
                    sourceSet in it.sourceSets && it.isNotOverrideOrInherited(sourceSet)
                }.map { it.toSerializable(sourceSet, locationResolver) }.distinct() // That distinct removes copies of autogenerated/inherited functions from data classes/Any class
                    .toFunctionsJson()
            }
            listOf(
                InkuireContentPage(
                    name = "${sourceSet.sourceSetID.sourceSetName}/${module.name}.inkuire.fdb",
                    strategy = renderingStrategy(callback, sourceSet)
                ),
                InkuireContentPage(
                    name = "${sourceSet.sourceSetID.sourceSetName}/${module.name}.inkuire.adb",
                    strategy = RenderingStrategy.Write(typesAncestryGraph(module, sourceSet).anyAndNothingAppender().toAncestryGraphJson())
                )
            )
        }
    }

    private fun typesAncestryGraph(documentable: Documentable, sourceSet: DokkaConfiguration.DokkaSourceSet): List<AncestryGraph> {
        return documentable.children.filter { sourceSet in it.sourceSets }.fold(emptyList<AncestryGraph>()) { acc, elem ->
            acc + typesAncestryGraph(elem, sourceSet)
        } + documentable.toAncestryEntry(sourceSet, documentable)
    }

    private fun Documentable.toAncestryEntry(sourceSet: DokkaConfiguration.DokkaSourceSet, parent: Documentable): List<AncestryGraph> = when (this) {
        is DClasslike ->
            if (this is WithSupertypes) {
                listOf(
                    AncestryGraph(
                        dri.toSerializable(), (STypeConstructor(dri.toSerializable(), getPossibleGenerics())),
                        (
                            supertypes[sourceSet]?.map { it.typeConstructor.toSerializable() }
                                ?: emptyList()
                            )
                    )
                )
            } else {
                listOf(AncestryGraph(dri.toSerializable(), (STypeConstructor(dri.toSerializable(), getPossibleGenerics())), emptyList()))
            }
        is DTypeAlias ->
            listOf(AncestryGraph(dri.toSerializable(), (STypeConstructor(dri.toSerializable(), getPossibleGenerics())), listOfNotNull(underlyingType[sourceSet]?.toSerializable())))
        else -> emptyList()
    } + if (this is WithGenerics)
        generics.flatMap { it.toAncestryEntry(sourceSet, this) }
    else emptyList()

    private fun Documentable.getPossibleGenerics() = if (this is WithGenerics) {
        this.generics.map {
            it.toSerializable().variantTypeParameter
        }
    } else {
        emptyList()
    }

    private fun DClasslike.getFunctions(): List<DFunction> = (
        functions +
            classlikes.flatMap { it.getFunctions() } +
            properties.mapNotNull { it.getter } + if (this is DClass) constructors else emptyList()
        ).map {
        it.copy(
            generics = if (this is WithGenerics) (it.generics + this.generics).distinctBy { it.name } else it.generics
        )
    }

    protected fun DFunction.isNotOverrideOrInherited(sourceSet: DokkaConfiguration.DokkaSourceSet): Boolean {
        return when (val src = this.sources[sourceSet]) {
            is DescriptorDocumentableSource -> {
                val desc = src.descriptor as CallableMemberDescriptor
                (!(desc.kind == FAKE_OVERRIDE || desc.overriddenDescriptors.isNotEmpty())) // parenthesis becuase Kotlin has stupid parser
            }
            is PsiDocumentableSource -> true // TODO: Find way of finding whether PsiMethod is actually override
            else -> true
        }
    }

    protected fun List<SDFunction>.toFunctionsJson(): String = CustomGson.instance.toJson(this)
    protected fun List<AncestryGraph>.toAncestryGraphJson(): String = CustomGson.instance.toJson(this)
}
